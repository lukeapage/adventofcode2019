(function() { const drawToMap = (path, map, bit, startPos) => { const pos = { ...startPos }; let steps = 0; for(let i = 0; i < path.length; i++) { const action = path[i]; let dir = { x: 0, y: 0 }; switch(action[0]) { case 'R': dir.x++; break; case 'L': dir.x--; break; case 'U': dir.y--; break; case 'D': dir.y++; break; } for(let j = 0; j < Number(action.slice(1)); j++) {  steps++; pos.x += dir.x; pos.y+= dir.y; if (!map[pos.y]) {map[pos.y] = [];} if (!map[pos.y][pos.x]) { map[pos.y][pos.x] = {}; } if (!map[pos.y][pos.x][bit]) { map[pos.y][pos.x][bit + 'steps'] = steps; } map[pos.y][pos.x][bit] = true;  } } }; const createMap= (w, h) => { return []; }; const createAndDraw = (size, inst1, inst2) => { let map = createMap(size, size); drawToMap(inst1, map, 1, { x: size/2, y: size/2 }); drawToMap(inst2, map, 2, { x: size/2, y: size/2 }); return map; }; const findClosestIntersection = (map, port) => { let dist = Infinity; let delay = Infinity; for(var y = 0; y < map.length; y++) { if (!map[y]) { continue;} for(var x = 0; x < map[y].length; x++) { if (!map[y][x]) {continue;} if (map[y][x][1] === true && map[y][x][2] === true) { const newDelay = map[y][x]['1steps'] + map[y][x]['2steps']; if (newDelay < delay) { delay = newDelay; dist = Math.abs(y - port) +  Math.abs(x - port); } } } } return delay;  }; const size = 30000; const [one, two] = document.body.innerText.split('\n');const map = createAndDraw(size, one.split(','), two.split(',')); console.log(findClosestIntersection(map, size / 2)); })()